# JVM. Организация памяти, сборщики мусора.
## Код для исследования.
```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
## Начало работы:
При исполнении  байт- кода JVM  последовательно загружает в область памяти  **Metaspace** скомпилированные  классы **JvmComprehension**, **Object** , **System** и **String**  соответствующим ClassLoader’ом с верификацией кода класса на валидность. В момент вызова метода main  в области памяти stack выделяется frame (main) , который является текущим.
## Организация памяти:

1. В текущем *frame(main)* примитиву **i**  присваивается значение **int i = 1**;
1. В области памяти *heap* выделяется место для экземпляра класса  **Object** , а затем в *frame(main)* размещается ссылка  на объект  **о**;
1. В области памяти *heap* выделяется место для поля   класса  **Integer** c присвоением значения **2** , а затем в *frame(main)8 размещается ссылка  на объект  **ii**;
1. В области памяти *stack* выделяется *frame (printAll )* , который становиться текущим  и в нем формируются ссылки на объекты **ii**  и **о** . так же присваивается значение **int i**;
1. В области памяти *heap* выделяется место для поля   класса  **Integer** c присвоением значения **700** , а затем в *frame(printAll)* размещается ссылка  на объект  **uselessVar** ;
1. В области памяти *stack* выделяется *frame (println)* , который становиться текущим. В области памяти *heap* выделяется место для объекта **String**  c инициализацией значения **“ o.toString() + i + ii”**. В *frame (println)*   размещается ссылка  на  этот объект  - **this.** . Ссылка  на объект  **uselessVar** , вследствие завершения метода   printAll  и отсутствие других связей разрушается , и объект  **uselessVar** уничтожается сборщиком мусора как и текущий объект **String** .
1. В области памяти *heap* выделяется место для объекта **String**  c инициализацией значения **"finished"**. В *frame (println)*   обновляется ссылка **this.** на  этот объект . При успешном завершении метода println сборщиком мусора уничтожается ссылка и объект.

## Завершение работы :
Область памяти *stack* ,выделенная потоку **main**, и связанные объекты в *heap* очищаются сборщиком мусора.